#summary A very effective bitmap downloader
#labels Featured,Phase-Implementation

= BitmapDownloader =

Many Android application do not embed all graphical resources inside the .apk installation package, and need to download efficiently dynamically bitmaps from Internet. Moreover, most of the time, those bitmaps need to be persisted locally, in order to prevent to download them every time they need to be displayed. In some cases, the bitmap need to have a footprint applied to it, when turned into an Android `android.graphics.Bitmap` instance. In addition, bitmaps also need to be kept in memory via a caching mechanism, because they are very frequently accessed, especially in `android.widget.ListView` rows, but they should not saturate the memory consumption. At last, the bitmap needs to be binded to its view (typically an `ImageView`), and it is required to involve that binding at the end of the bitmap retrieval process, and to know the final status of the binding.

Most of the open-source components handle some of those constraints, but not all at the same time. It would be very handy to have a component at hand which addresses all those challenges at the same time.

== `BitmapDownloader`: an all-in-one component for handling Android bitmaps == 

We have designed the "BitmapDownloader" component with those requirements in mind, and we have strived to make it both efficient and flexible. Because that kind of component is very critical, we have introduced a thin layer of abstraction, so that it can be unitary-tested (the unitary tests are available in the project).

The `BitmapDownloader` component proposes multiple instances, so as to provide a separate and independent caching feature. Its interface is very simple, since it also proposes to retrieve a bitmap and attach it to a `android.view.View` and to clear the memory cache.

The "BitmapDownloader" works closely with a `DownloadInstructions.Instructions` interface, which will be used throughout the bitmap retrieval and attaching process so as to provide instructions.

== How to use the "BitmapDownloader" component ==

Here are the steps that you need to take:

 # Set up the "BitmapDownloader" parameters: a typical location where to tune those parameters is the `Application.onCreate()` method. You may define:
  * the `BitmapDownloader.INSTANCES_COUNT` variable to indicate how many instances should be created (defaults to `1`),
  * optionally, the `BitmapDownloader.MAX_MEMORY_IN_BYTES` integer array variable to indicate the RAM high water mark that each instance should respect,
  * optionally, the `BitmapDownloader.LOW_LEVEL_MEMORY_WATER_MARK_IN_BYTES` integer array variable to indicate the RAM low water mark that each instance should respect,
  * very optionally, the `BitmapDownloader.IMPLEMENTATION_FQN` string variable which indicates the `BitmapDownloader` class Fully Qualified Name, if you have decided to derive from the built-in one.
# Create an implementation of the `DownloadInstructions.Instructions` interface: most of the time, you will need only one instance of that interface, which you can define in a `static` way. An already descent implementation is the `DownloadInstructions.AbstractInstructions` class, and if you want to define your own, it is very likely that you should derive from it.
# Every time you need to bind a bitmap to an Android `android.view.View` (in most cases a `android.widget.ImageView`), invoke the `BitmapDownloader.get()` method from any thread (except if you use the version of the method which takes a `boolean` as first argument, and that you set that flag `true`), and the "BitmapDownloader" will take
 # the `view` Android view a bitmap should be bound to,
 # the bitmap `imageUid` unique identifier string,
 # some optional-but-very-handy ìmageSpecs` specifications object,
 # an Android `android.os.Handler` (which will be used to run certain methods in the UI thread),
 # and the previously created `DownloadInstructions.Instructions` instance.

The component will handle everything for you, and in particular, if the bitmap is already in memory, no HTTP request will be performed.

== The "BitmapDownloader" command workflow ==

To ease the explanation, we will refer to the "command" term to refer to the action of invoking the `BitmapDownloader.get()`: this command is defined by the couple of the `android.view.View` and `bitmapUid` provided as parameters.

When you invoke the `BitmapDownloader.get()` method, i.e. run a "command", the "BitmapDownloader" follows this overall workflow:
 # first, it asks the `DownloadInstructions` if it can provide the bitmap "locally", that is to say from a resource bundled in the application .apk. This is done by invoking the `DownloadInstructions.hasLocalBitmap()` method: if the method answers `true`, then the `DownloadInstructions.onBindLocalBitmap()` method is invoked, and the command ends;
 # then, it turns the bitmap `imageUid` into a URL, by invoking the `DownloadInstructions.computeUrl()` method. The fact to turn the bitmap unique identifier into an actual URL is very convenient, because it enables you to centralize in one place that computation. It may appear overkill at first sight, but with the help of the additionally provided `imageSpecs` parameter, you can re-use the same `DonwloadItructions` for various purposes.
 # then, it looks whether the bitmap asks for would not be already in memory, based on the previously computed URL. If this is the case, the binding is run and the command completes ;
 # then, it asks the `DownloadInstructions` whether a temporary bitmap is available while the rest of the command is executed (which may take time, and we'd prefer the `View` to be temporarily binded to a bitmap). This is done through the `DownloadInstructions.hasTemporaryBitmap()` method call: if the method returns `true`, then the `DownloadInstructions.onBindTemporaryBitmap()` is invoked. Whatever, the rest of the command execution continues.
 # at this stage, we know that the bitmap is not in memory cache. It then asks if the bitmap could not be retrieved from a local persistent instance: this is done by invoking the `DownladInstructions.getInputStream()` method: if the method returns a non-null `InputStream`, it will be used to re-create the bitmap, bind it via the `DownloadInstruction.onBindBitmap()` method, and the command ends. This is where you can plug the persistence.
 # at this stage, we know that the bitmap is neither available in memory cache, nor in the local persistent: the component needs to download it. It invokes the `DownladInstructions.downloadInputStream()`: if this method succeeds, it returns an `InputStream`. Otherwise the command ends ;
 # then, the previously retrieved `InputStream` will be provided to the `DownloadInstructions.onInputStreamDownloaded()` method that the "BitmapDownloader" will invoke. This is a placeholder where you may want to persist locally the bitmap ;
 # then, the previously retrieved `InputStream` needs to be turned into an actual `Bitmap`. On that purpose, the "BitmapDownloader" invokes the `DownloadInstructions.convert()` method: this is a good place to perform graphical operations to the bitmap, if necessary ;
 # at last, the `DownloadInstruction.onBindBitmap()` method is invoked with the extracted bitmap and the command ends. 

The strategy used internally during that workflow is a kind of last-in-first-out (LIFO) when serving the commands, because, in the case the component is used in a `ListView`, we prefer to have the lastly displayed rows properly updated graphically, instead of the ones which have already disappeared from the screen because the `ListView` has already been scrolled vertically. This policy has shown that it is a good choice, when confronted to the reality.

Three major things:
 * When using the `BitmapDownloader.get()` method which takes a `boolean` as a first argument, it is supposed that the caller is the UI thread, and the component attempts to perform some optimizations, which will be effective if the bitmap asks for is already in RAM.
 * Some of the `DownloadInstructions` method callbacks will be run by the "BitmapDownloader" in the UI thread (only the ones, which require that): it is very important that those methods execute as fast as possible, in order to prevent from a non responsive User Interface!
 * You can use the `BitmapDownloader.get()` method with a `null` 'view` argument: no binding will be obviously run, but the bitmap will be extracted from the local persistent and put in cache, or donwloaded from the network and then put in cache. This means that you can use the "BitmapDownloader" component to pre-load bitmaps.

== The `DownloadInstructions` notifications ==

As we have seen, the `DownloadInstructions` is requested so as to guide the bitmap "command", but the `BitmapDownloader` also notifies during the command execution workflow. Here are the methods which may be invoked:

 * `DownloadInstructions.onBitmapReady()`: this method will be invoked by the "BitmapDownloader" to indicate when the bitmap is eventually available at the end of the command. It is even invoked when the provided `view` parameter is `null`. The parameters enable to get more information.
 * `DownloadInstructions.onBitmapBound()`: this method will be invoked by the "BitmapDownloader", always after the `DownloadInstructions.onBindTemporaryBitmap()/onBindLocalBitmap()/onBindBitmap()` method it has been invoked, to indicate that the binding process is over. The parameters enable to get more information.

== Some built-in `imageSpecs` classes ==

You will find in the `DownloadSpecs` container class, some convenient classes, which helps to implements the `DownloadInstruction` interface:

 * `TemporaryImageSpecs`: this class holds a reference to the Android resource identifier where a temporary bitmap may be extracted from, while the rest of the `BitmapDownloader` instance is running a command ;
 * `TemporaryAndNoImageSpecs`: this class is a `TemporaryImageSpecs`, and holds an alternative Android resource identifier, if the bitmap could not be downloaded ;
 * `DefaultImageSpecs`: this class is a `TemporaryImageSpecs`, and holds a size (an `int`) information ;
 * `OrientedImageSpecs`: this class holds a size (an `int`) information, and an orientation flag (a `boolean`) ;
 * `SizedImageSpecs`: this class is a `TemporaryImageSpecs`, and holds a width and a height information (two `int`).

The idea behind those built-in classes, is to implement the `DownloadInstructions` methods by testing the actual class of the provided `imageSpecs` argument.

== The memory water marks ==

The "BitmapDownloader" lets you set, for each instance, define how much memory, at most, it should consumes for its caching, via a traditional memory high/low-level water mark mechanism. As explained above, you may fine-tune two parameters:

 * the high-level water mark: the component monitors the space consumed by each 'Bitmap' in memory, and when this upper limit is reached, a cleaning process is run, so as to free memory ;
 * the low-level water mark: when clearing the cache, as many `Bitmap` instances will be removed from memory as necessary, so that this low-level memory consumption is reached. However, the component does not discard from memory randomly the `Bitmap` instances: it keeps track on how many times a `Bitmap` has been requested (every time the `BitmapDownloader.get()` method is invoked, so as to discard the ones that have less been requested. This clearing strategy may be opened in the future...

You may want to empty the cache yourself: on that purpose, you may invoke the `empty()` method.

== How to couple the "BitmapDownloader" with the "Persistence" ==

…

== Some noteworthy `BitmapDownloader` internal implementation details ==

The component uses two thread pools, in order to run two kinds of commands...

Now, in a stressed environment, it is important that the component behaves properly, and we have done our best to handle this situation properly. The component takes great care about:

 * optimization: invoking many times that component, and especially for the same `View` for different URLs or for the same URL, should not incur useless operations, like retrieving the actual bitmap from the persistence, from the Internet, like binding the bitmap to the view ;
 * end-user experience: no matter how the end-user interacts with the User Interface, his screen should be always as much as possible up-to-date regarding the displayed images.
 * memory conservation: because an application may display a huge bunch of bitmaps, it is very important that it does not get saturated by its caching system. The component can be split into several instances, and each instance can state how it should behave regarding the memory consumption, through a memory low/high water mark mechanism.

This is the reason why, when you invoke the `BitmapDownloader.get()` method, i.e. run a "command", some considerations are taken into account:
 # a first internal command is triggered, and the following workflow is run…
 # the instance will look whether the same command is already been executed…Ò
